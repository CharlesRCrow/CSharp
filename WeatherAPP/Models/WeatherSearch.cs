using System.Net.Http.Headers;
using Newtonsoft.Json.Linq;
using System.Net.Http;

namespace WeatherAPP.Views.Models
{
 public class WeatherSearch
    {
        public static async Task<Dictionary<string, string>> GetLoc(string address)
        {
            Dictionary<string, string> error = new Dictionary<string, string>
            {
                { "Error", "Connection Unsuccessful"}
            };            

            // connect and retrieve results from geocode api
            HttpClient locationClient = new HttpClient();
            HttpRequestMessage locationRequest = new HttpRequestMessage(HttpMethod.Get, $"https://geocode.maps.co/search?q={address}&api_key=658c6db1d8ea5951371902vxcf86d7c");

            HttpResponseMessage locationHttpResponseMessage = await locationClient.SendAsync(locationRequest);
            
            // return error message if connection unsuccessful
            if (!locationHttpResponseMessage.IsSuccessStatusCode) return error;

            string locationResponse = await locationHttpResponseMessage.Content.ReadAsStringAsync();
            
            // return empty list if there are no results
            if (locationResponse == "[]")
            {
                return new Dictionary<string, string>();
            }

            // split string into usable format for JObject parse
            string firstResponse = locationResponse.Split('{', '}')[1];
            firstResponse = "{" + firstResponse + "}";

            JObject jsonLocation;
            JToken? latitude;
            JToken? longitude;

            try
            {
                jsonLocation = JObject.Parse(firstResponse);
                latitude = jsonLocation.SelectToken("lat");
                longitude = jsonLocation.SelectToken("lon");                
            }
            catch 
            {
                return error;
            }

            // return dictionary containing lat and long.  Return noResults dictionary if unsuccessful
            if (latitude?.Type != JTokenType.Null && longitude?.Type != JTokenType.Null)
            {
                Dictionary<string, string> latLong = new Dictionary<string, string>
                {
                    { "Latitude", (string) latitude!},
                    { "Longitude", (string) longitude!}
                };

                return latLong;   
            }
            else
            {
                Dictionary<string, string> noResults = new Dictionary<string, string>
                {
                    { "NoResults", "No Results"}
                };

                return noResults;
            }
        }

        public static async Task<List<Dictionary<string, string>>> GetWeather(Dictionary<string, string> latLong, string weatherSelect)
        {
            // generate empty list of dictionaries
            List<Dictionary<string, string>> weatherList = new List<Dictionary<string, string>>();

            // dictionaries that will be included if unsuccessful
            Dictionary<string, string> error = new Dictionary<string, string>
            {
                { "Error", "Connection Unsuccessful"}
            };

            Dictionary<string, string> noResults = new Dictionary<string, string>
            {
                { "NoResults", "No Results"}
            };

            // if latlong dictionary generated by GetLoc function contain error/no results message.  Pass the message out of function to be used by controller.      
            if (latLong.ContainsKey("Error"))
            {
                weatherList.Add(error);
                return weatherList;
            }

            if (latLong.ContainsKey("NoResults"))
            {
                weatherList.Add(noResults);
                return weatherList;
            }            
            
            // use lat/long location data to get weather results from api
            string latitude = latLong["Latitude"];
            string longitude = latLong["Longitude"];
            string weatherLocation = $"https://api.weather.gov/points/{latitude},{longitude}";
            
            // get grid id, x and y for forecast                               
            HttpClient client = new HttpClient();
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, weatherLocation);
            ProductInfoHeaderValue header = new ProductInfoHeaderValue("WeatherCrow", "1.0");
            ProductInfoHeaderValue comment = new ProductInfoHeaderValue("(+https://crowsearch.azurewebsites.net/Home/WeatherSearch)");

            client.DefaultRequestHeaders.UserAgent.Add(header);
            client.DefaultRequestHeaders.UserAgent.Add(comment);

            HttpResponseMessage httpResponseMessage = await client.SendAsync(request);
            string response = await httpResponseMessage.Content.ReadAsStringAsync();

            JObject root;
            JToken? token;

            try
            {
                root = JObject.Parse(response);
                token = root.SelectToken("properties");               
            }
            catch
            {
                weatherList.Add(error);
                return weatherList;
            }
            
            // return error message if unsuccessful
            if (token is null)
            {
                weatherList.Add(error);
                return weatherList;
            }
            
            JToken? xCord = token.SelectToken("gridX");
            JToken? yCord = token.SelectToken("gridY");
            JToken? gridID = token.SelectToken("gridId");
            HttpRequestMessage? forecastRequest;

            // retrieve seven day or hourly forecast
            if (weatherSelect.Equals("seven"))
            {
                forecastRequest = new HttpRequestMessage(HttpMethod.Get, 
                    $"https://api.weather.gov/gridpoints/{gridID}/{xCord},{yCord}/forecast");
            }
            else if (weatherSelect.Equals("hourly"))
            {
                forecastRequest = new HttpRequestMessage(HttpMethod.Get, 
                    $"https://api.weather.gov/gridpoints/{gridID}/{xCord},{yCord}/forecast/hourly");
            }
            else
            {
                weatherList.Add(error);
                return weatherList;
            }

            HttpResponseMessage httpResponseForecast = await client.SendAsync(forecastRequest);

            // return error message if not successful
            if (!httpResponseForecast.IsSuccessStatusCode)
            {
                weatherList.Add(error);
                return weatherList;
            }

            string forecastResponse = await httpResponseForecast.Content.ReadAsStringAsync();

            // parse forecast results into jArray

            JObject forecast;
            JArray dailyForecast;
            
            try
            {
                forecast = (JObject)JObject.Parse(forecastResponse)["properties"]!;
                dailyForecast = (JArray)forecast["periods"]!;                
            }
            catch
            {
                weatherList.Add(error);
                return weatherList;
            }
            
            if (dailyForecast is null) 
            {
                weatherList.Add(noResults);
                return weatherList;
            }

            // transform JArray into list of dictionaries            
            foreach (JToken day in dailyForecast ?? throw new InvalidOperationException())
            {
                Dictionary<string, string> dayWeather = new();
                
                if (day.Type != JTokenType.Null)
                {
                    dayWeather = new()
                    {
                        { "Name", (string)day["name"]! },
                        { "Temp", (string)day["temperature"]! },
                        { "WindSpeed", (string)day["windSpeed"]! },
                        { "WindDirection", (string)day["windDirection"]! },
                        { "Humidity", (string)day["relativeHumidity"]!["value"]! },
                        { "Dewpoint", (string)day["dewpoint"]!["value"]! },
                        { "DailyPrecipitation", (string)day["probabilityOfPrecipitation"]!["value"]! },
                        { "DetailedForecast", (string)day["detailedForecast"]! },
                        { "ShortForecast", (string)day["shortForecast"]! },
                        { "StartTime", (string)day["startTime"]! },
                        { "EndTime", (string)day["endTime"]! }
                    };

                    // if no precipitation data is included the assumed value is zero
                    dayWeather[$"DailyPrecipitation"] = dayWeather[$"DailyPrecipitation"] is null ? "0" : dayWeather[$"DailyPrecipitation"];
                                    
                    DateTime startTime;
                    DateTime endTime;
                    
                    // format time period into useful format.
                    if (!DateTime.TryParse(dayWeather["StartTime"], out startTime) || !DateTime.TryParse(dayWeather["EndTime"], out endTime))
                    {
                        dayWeather["Period"] = "INVALID";
                    }
                    else
                    {
                        dayWeather["Period"] = $"{startTime.DayOfWeek}  {startTime.Hour}:00 to {endTime.Hour}:00";
                    }
                    
                }
                // add generated dictionary into weatherList
                weatherList.Add(dayWeather);
            }

            // return weatherList if list has data.  Empty list if not.
            return weatherList.Count == 0 ? new List<Dictionary<string, string>>() : weatherList;
        }
    }
}